//                       MFEM Example 9 - Parallel Version//// Compile with: make ex9p//// Sample runs://    mpirun -np 4 ex9p -m ../data/periodic-segment.mesh -p 0 -dt 0.005//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/amr-quad.mesh -p 1 -rp 1 -dt 0.002 -tf 9//    mpirun -np 4 ex9p -m ../data/star-q3.mesh -p 1 -rp 1 -dt 0.004 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 1 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 2 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 3 -rp 2 -dt 0.0025 -tf 9 -vs 20//    mpirun -np 4 ex9p -m ../data/periodic-cube.mesh -p 0 -o 2 -rp 1 -dt 0.01 -tf 8////    MFEM_adv steady-state test runs//    1D currently not implemented.//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 5 -s 1 -col 1//    2D//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 5 -s 1 -col 1//    2D AMR//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 5 -s 1 -col 1//    High azimuthal resolution test.//    mpirun -np 4 ex23TRp -m ../data/inline-segment.mesh -p 0 -rp 0 -tf 2000000 -dt 1000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 100000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/amr-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 2000000 -s 1 -col 5 -sna 12 //    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 0.3 -dt 0.01 -s 1 -col 5 -sna 5//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 1 -tf 0.23 -dt 0.01 -s 1 -col 5 -sna 5     //    mpirun -np 2 exTRguts -m milan_data/ALE_quad.mesh -rs 1//// Description:  This example code solves the time-dependent advection equation//               du/dt + v.grad(u) = 0, where v is a given fluid velocity, and//               u0(x)=u(0,x) is a given initial condition.////               The example demonstrates the use of Discontinuous Galerkin (DG)//               bilinear forms in MFEM (face integrators), the use of explicit//               ODE time integrators, the definition of periodic boundary//               conditions through periodic meshes, as well as the use of GLVis//               for persistent visualization of a time-evolving solution. The//               saving of time-dependent data files for external visualization//               with VisIt (visit.llnl.gov) is also illustrated.// This problem seems to like an FFC rekaxation...#include "mfem.hpp"#include <fstream>#include <iostream>#include "TRgutsp.cpp"using namespace std;using namespace mfem;int main(int argc, char *argv[]){   // 1. Initialize MPI.   int num_procs, myid;   MPI_Init(&argc, &argv);   MPI_Comm_size(MPI_COMM_WORLD, &num_procs);   MPI_Comm_rank(MPI_COMM_WORLD, &myid);   // 1.5 Parse mesh command-line option and initialize mesh.   const char *mesh_file = "./meshes/periodic-hexagon.mesh";   int ser_ref_levels = 2;   int par_ref_levels = 0;   //int order = 3;   OptionsParser args_mesh(argc, argv);   args_mesh.AddOption(&mesh_file, "-m", "--mesh",                       "Mesh file to use.");   args_mesh.AddOption(&ser_ref_levels, "-rs", "--refine-serial",                       "Number of times to refine the mesh uniformly in serial.");   args_mesh.AddOption(&par_ref_levels, "-rp", "--refine-parallel",                       "Number of times to refine the mesh uniformly in parallel.");   //args_mesh.AddOption(&order, "-o", "--order",   //                    "Order (degree) of the finite elements.");   args_mesh.Parse();   // 3. Read the serial mesh from the given mesh file on all processors. We can   //    handle geometrically periodic meshes in this code.   Mesh *mesh = new Mesh(mesh_file, 1, 1);   int dim = mesh->Dimension();   // 5. Refine the mesh in serial to increase the resolution. In this example   //    we do 'ser_ref_levels' of uniform refinement, where 'ser_ref_levels' is   //    a command-line parameter. If the mesh is of NURBS type, we convert it   //    to a (piecewise-polynomial) high-order mesh.   for (int lev = 0; lev < ser_ref_levels; lev++)   {      mesh->UniformRefinement();   }   if (mesh->NURBSext)   {      mesh->SetCurvature(1);      //mesh->SetCurvature(max(order, 1));   }   Vector bb_min, bb_max;    mesh->GetBoundingBox(bb_min, bb_max, 1);   //mesh->GetBoundingBox(bb_min, bb_max, max(order, 1));   // 6. Define the parallel mesh by a partitioning of the serial mesh. Refine   //    this mesh further in parallel to increase the resolution. Once the   //    parallel mesh is defined, the serial mesh can be deleted.   ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);   delete mesh;   for (int lev = 0; lev < par_ref_levels; lev++)   {      pmesh->UniformRefinement();   }   // Run TR example on the ParMesh pmesh.   TRguts::TRmain(pmesh, bb_min, bb_max);   delete pmesh;    MPI_Finalize();   return 0;}